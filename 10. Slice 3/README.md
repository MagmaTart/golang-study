# 10. Slice 3

슬라이스에서 특정 위치에 요소를 삽입하고 삭제하는 방법을 알아보고 가자.

### 슬라이스 내 특정 위치에 요소 삽입

앞서 슬라이스가 C++의 `std::vector`와 비슷하다고 했었는데, 한 가지 크게 다른 점이 있다면 __특정 위치에 요소 삽입 및 삭제__ 를 수행하는 함수가 없다는 것이다. 슬라이스에서 그렇게 하려면 삽입과 삭제 함수를 직접 구현해서 사용해야 한다.

먼저 요소 삽입부터 구현해 보자. 슬라이스 하나를 정의하고, 인덱스 3 위치에 새로운 원소를 삽입할 것이다.

```go
slc := []int{1, 2, 3, 4, 5}
idx := 3
slc = append(slc[:idx+1], slc[idx:]...)
slc[idx] = 6    // [1, 2, 3, 6, 4, 5]
```

코드의 원리는 간단하다. 삽입하고 싶은 위치의 인덱스를 기준으로 슬라이스를 두 부분으로 나누어 붙인다. 위의 세 번쨰 라인처럼 슬라이싱하면 `[1, 2, 3, 4]`과 `[4, 5]`가 각각 나와 append되어 `[1, 2, 3, 4, 4, 5]`가 될 것이다. 삽입할 인덱스에 위치하던 값이 두번 복사되었으므로, 그 인덱스의 값만 새로운 값으로 바꿔주면 끝이다.

그런데 append를 이용한 방법의 경우, 슬라이스의 마지막 인덱스에는 같은 방법으로 요소를 삽입할 수 없다. `idx+1`로 슬라이싱할 때 범위를 넘어가기 때문이다. 따라서 이럴 경우는 예외처리를 하나 해 주어야 한다.

```go
if idx < len(slc) {
    slc = append(slc[:idx+1], slc[idx:]...)
    slc[idx] = 6
} else {
    slc = append(slc, 6)
}
```

이번에는 `append`가 아니라 `copy`를 이용해서 삽입해보자. 위와 상황은 동일하다.

```go
slc := []int{1, 2, 3, 4, 5}
idx := 3
slc = append(slc, 6)    // append할 값은 무엇이던 상관이 없다.
copy(slc[idx+1:], slc[idx:])
slc[idx] = 6    // [1, 2, 3, 6, 4, 5]
```

`copy`를 이용한 삽입이 이해하기에 약간 더 쉬운 것 같다. 먼저 슬라이스에 값 하나를 append해서 슬라이스의 용량을 늘려준다. 이제 삽입할 인덱스부터 슬라이스의 끝까지 copy해서 뒤로 한칸 밀어준다. `copy`는 두 개의 슬라이스 중에서 짧은 것만큼만 복사를 하기 때문에, 기존 슬라이스의 맨 끝 값은 사라진다. 이제 슬라이스가 append떄와 같은 모양인 `[1, 2, 3, 4, 4, 5]`가 되었으므로, 인덱스에 새로운 값을 넣어주면 끝난다.\
`copy`를 이용한 삽입도 `append`때와 같은 예외처리는 해 주어야 한다.

슬라이스 안에 슬라이스를 삽입하는 것도 같은 원리로 가능하다.

```go
slc := []int{1, 2, 3, 4, 5}
ttt := []int{7, 8, 9}
idx := 3
slc = append(slc, ttt...)
copy(slc[idx+len(ttt):], slc[idx:])
copy(slc[idx:], ttt)    // [1, 2, 3, 7, 8, 9, 4, 5]
```

삽입할 인덱스부터 새로운 슬라이스가 들어갈 공간을 만들어놓고, 그 위치에 삽입할 슬라이스를 복사하는 방식이다.

### 슬라이스 내 특정 위치의 요소 삭제

삭제는 직관적으로 생각하면 간단하다. 삭제할 인덱스의 다음 인덱스부터 슬라이싱해서, 삭제할 인덱스부터 덮어씌워주면 된다.

```go
slc := []int{1, 2, 3, 4, 5}
idx := 3
slc = append(slc[:idx], slc[idx+1:]...)
```

여러개를 동시에 삭제할 때도 마찬가지이다. `i`번째 인덱스부터 `k`개 삭제한다면, 아래와 같이 하면 될 것이다.

```go
slc := []int{1, 2, 3, 4, 5, 6, 7}
i := 2
k := 3
slc = append(slc[:i], slc[i+k:]...)
```

슬라이스에서 요소 삭제 시 주의해야 할 점이 하나 있는데, 슬라이스의 Capacity 관련이다.\
위와 같이 삭제할 부분 뒤의 슬라이스를 떙기는 식으로 삭제를 하면, 슬라이스의 Length는 바로 줄어들지만 Capacity는 그대로이다. 내부 배열이 아직 그대로 존재하기 때문이다.

```go
slc := []int{1, 2, 3, 4, 5, 6, 7}       // Length : 7, Capacity : 7
i := 2
k := 3
slc = append(slc[:i], slc[i+k:]...)     // Length : 4, Capacity : 7
```

이는 메모리 누수를 일으킬 수 있는 치명적인 문제가 된다. 포인터들의 슬라이스라면 상황은 더 심각해질 것이다.\
이런 상황을 방지하기 위해서, __삭제하는 개수만큼 뒤에서 메모리를 직접 해제__ 해주어야 한다. 메모리의 해제는 해당 변수를 `nil`로 만들어 할 수 있다.
