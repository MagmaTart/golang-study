# 14. Function 1

### 함수에 Value 전달

Go의 함수는 기본적으로 __Call-by-Value__ 방식이다. 함수가 실행되어 스택에 쌓일 때, 함수의 인자가 복사된다는 이야기이다. 그러나 Call-by-Reference를 구현하지 못한다는 말은 아니다. Go에도 포인터가 있으므로, 포인터를 이용해 함수로 _메모리상의 어드레스_ 를 전달하기만 하면 Call-by-Reference를 구현할 수 있다. 함수 내부에서는 `*` 연산자를 이용해 _해당 메모리가 가리키는 주소의 객체_ 를 참조하거나 변경할 수 있다.

이러한 Go 함수의 특성을 가장 쉽게 볼 수 있는 예제가 바로 인자로 슬라이스가 넘어가는 함수이다. 아래의 예제를 보자.

```go
func slice_by_value_test(slc []int) {
    slc[0] = 10             // slc : {10, 2, 3, 4, 5}
    slc = append(slc, 6)    // slc : {10, 2, 3, 4, 5, 6}
}

func main() {
    slc := []int{1, 2, 3, 4, 5}     // slc : {1, 2, 3, 4, 5}
    slice_by_value_test(slc)        // slc : {10, 2, 3, 4, 5}
}
```

슬라이스를 `{1, 2, 3, 4, 5}`로 초기화했다. 이 슬라이스를 함수에 그대로 넘겨서, 함수는 실행시에 슬라이스를 복사해갔다. 함수는 0번째 요소를 변경하고, 하나의 값을 append했다. 함수 내에서 슬라이스의 Length는 6, Capacity는 10이 되었다. 그리고 다시 main에 와서 확인해보니, 방금 넘겨준 슬라이스의 내부 배열 값이 함수에서 건든대로 바뀌어 있는 것을 확인할 수 있었다. 그러나 Length와 Capacity는 그대로 5였다.

이런 일이 발생하는 이유는, 슬라이스의 구조에 기인한다. 슬라이스는 _내부 배열의 시작 포인터, 길이, 용량_ 의 세 가지 값으로 이루어진 구조체라고 이야기했었다. 함수의 인자로 슬라이스가 넘어가 복사가 일어날 경우, 내부적으로는 저 __세 개의 값이 복사된 새로운 슬라이스__ 가 만들어진다. 그러나 슬라이스 내부 배열의 포인터까지 그대로 복사되기 때문에, 함수 외부의 슬라이스와 __같은 배열을 공유하면서 독립된 Length와 Capacity를 가진__ 슬라이스가 만들어지는 것이다.

그래서 함수 내부에서 슬라이스의 길이와 용량이 변경되어도, 함수 밖의 슬라이스와는 독립적이므로 영향이 없다. 하지만 내부 배열은 공유중이기 때문에, 값의 변경이 그대로 함수 외부에서도 보이게 되는 것이다.

### 함수에 Pointer 전달

위의 예제에서 슬라이스를 포인터로 넘기면 이야기가 달라진다.

```go
func slice_by_pointer_test(slc *[]int) {
    (*slc)[0] = 10              // slc : {10, 2, 3, 4, 5}
    *slc = append(*slc, 6)      // slc : {10, 2, 3, 4, 5, 6}
}

func main() {
    slc := []int{1, 2, 3, 4, 5}     // slc : {1, 2, 3, 4, 5}
    slice_by_pointer_test(&slc)     // slc : {10, 2, 3, 4, 5, 6}
}
```

슬라이스 포인터를 넘겨주게 되면, 함수는 인자로 __슬라이스 구조체의 어드레스__ 를 넘겨받는다. 해당 어드레스를 참조하면 함수 외부에서와 동일한 슬라이스 구조체에 접근할 수 있게 된다. 내부 배열의 포인터, 길이, 용량을 모두 하나로 공유하므로, 함수 내부에서의 변경이 함수 외부에서도 그대로 적용되는 것을 볼 수 있다.

포인터가 가지고 있는 어드레스에 있는 객체는 위와 같이 `*` 연산자를 이용해 참조할 수 있다. 윗 예제 두 번째 줄 `(*slc)[0] = 10` 부분에서 괄호를 저렇게 묶어주는 이유는 컴파일러의 동작 때문이다. Go 컴파일러는 `*slc[0] = 10`을 `*(slc[0]) = 10`으로 해석하는데, 포인터가 아닌 변수에 포인터 참조 연산자를 사용하므로 컴파일 에러가 발생한다. 따라서 명시적으로 __포인터가 가리키는 슬라이스__ 의 0번 요소임을 보이기 위해 저렇게 괄호로 묶는 것이다.

### 여러 개의 반환값을 가지는 함수

반환 값이 둘 이상인 함수를 작성할 수 있다. 함수의 반환형을 명시하는 부분에 괄호를 치고, 반환할 값들의 자료형을 순서대로 나열해주면 된다.

```go
func add_and_mul(a, b int) (int, int) {
	return a + b, a * b
}

func main() {
    add_result, mul_result := add_and_mul(30, 50)
    // add_result : 80, mul_result : 1500
}
```

두 정수 값 `a, b`를 인자로 받아, 더한 값과 곱한 값을 동시에 반환한다. 반환 값이 순서대로 두 개의 `int`이므로, `(int, int)`로 반환형을 작성했다.

### Named return values

Go 함수의 특징적인 기능 중 하나는, __반환 값에 이름을 줄 수 있다__ 는 것이다.

```go
func named_add_and_mul(a, b int) (add int, mul int) {
    add = a + b
    mul = a * b
    return
}

func main() {
    add_result, mul_result := named_add_and_mul(30, 50)
    // add_result : 80, mul_result : 1500
}
```

이름이 붙은 반환 값은 변수가 되며, 함수 내부에서 참조하고 변경할 수 있다. 또한 어떤 값을 반환할 것인지 이미 변수 이름으로써 알고 있으므로, `return`문에 반환 값들은 생략할 수 있다.
반환 값의 변수는 기본적으로 해당 자료형의 기본값으로 초기화된다. 위의 예제에서 `add`와 `mul`은 각각 0으로 초기화되었다.

### 가변인자 함수

가변인자 함수는 __인자의 개수가 정해져 있지 않은 함수__ 를 의미한다. Go에서 같은 자료형을 가지는 가변인자들은 슬라이스로써 전달받을 수 있다. 인자를 선언할 때 `...` 키워드를 이용한다.

```go
func add_all_values_in_slice(slc... int) int {
	total := 0
	for i := 0; i < len(slc); i++ {
		total += slc[i]
	}
	return total
}

func main() {
	result := add_all_values_in_slice(5, 6, 7, 8, 9)       // result : 35
	result = add_all_values_in_slice(5, 6, 7, 8, 9, 10)    // result : 45
}
```

`int`형의 가변인자들을 모두 받아 `slc`에 슬라이스 형태로 묶어 사용한다. 호출시에 인자는 몇 개가 들어가도 상관이 없다.

반대로 가변인자 함수에 슬라이스를 풀어서 전달하고 싶을 경우, 호출시에 `...` 키워드를 사용한다.

```go
func main() {
    slc := []int{1, 2, 3, 4, 5, 6, 7, 8, 9, 10}
    result := add_all_values_in_slice(slc...)
    fmt.Printf("Add result : %d\n", result)
}
```

`slc...`은 `slc` 슬라이스를 풀어서, 마치 각 요소들이 모두 따로 인자로 들어가는 것과 같이 구성해준다.
