# 9. Slice 2

### 슬라이스의 구조

슬라이스는 내부적으로 구조체로써 구현된다. 아래와 같이 세 가지 필드를 가지고 있다.
- 슬라이스가 참조하는 메모리 시작점의 포인터
- 현재 슬라이스의 길이(Length) 정보
- 현재 슬라이스의 용량(Capacity) 정보

Length와 Capacity는 마치 C++의 `std::vector`와 유사하다.\
Length는 슬라이스가 참조하는 메모리 시작점부터 슬라이스의 마지막 요소까지, 몇 개의 변수를 담고 있는가를 의미한다.\
Capacity는 현재 슬라이스가 참조하는 메모리 시작점부터 얼마나 메모리를 할당받아 있는가를 의미한다.

아래와 같이 슬라이스를 선언한다면

```
slc := []int{1, 2, 3}
```

슬라이스 slc는 Length 3, Capacity 3을 가지고 있는 상태가 될 것이다.

### make로 슬라이스 생성

슬라이스의 Length와 Capacity를 직접 지정하여 슬라이스를 생성할 수 있다. `make` 함수를 이용한다.

```go
slc := make([]int, 7, 20)   // Length 7, Capacity 20의 슬라이스 생성
```

슬라이스 초기 배열은 Length에 맞추어 각 타입에 맞게 초기화된다. `[]int` 슬라이스의 경우 모든 요소가 0으로 초기화된다.

Capacity를 생략할 경우, Capacity가 딱 맞게 생성된다.

```go
slc_b := make([]int, 15)    // Length 15, Capacity 15
```

### Length와 Capacity 확인

실제로 슬라이스의 Length와 Capacity가 어떻게 계산되는지 알아보자.\
먼저 실험할 슬라이스를 하나 선언한다.

```go
slc := []int{1, 2, 3, 4, 5, 6, 7, 8}
```

슬라이스를 초기화 값들과 함께 선언했으므로, 현재 `slc`는 Length 8, Capacity 8의 슬라이스이다.\
이제 슬라이싱을 한번 해보자.

```go
new := slc[2:6]
```

이렇게 슬라이싱하면, `slc`의 2번 인덱스부터 5번 인덱스까지만을 참조하는 슬라이스가 `new`에 대입된다.\
하지만 이 때 `new`의 Length와 Capacity를 확인해보면 각각 4, 5이다.\
기존 슬라이스에서 4개의 요소만 가지도록 슬라이싱했으므로 Length는 4가 당연하다. 하지만 Capacity는 아직도 기존 슬라이스의 배열 끝까지를 포함하는 __6__ 이다.\
이는 __슬라이싱을 통해 만들어진 슬라이스는 같은 배열을 공유__ 하기 때문이다. `slc`를 슬라이싱해서 나온 `new`는, `slc`와 내부 배열을 공유하면서 시작 포인터의 위치와 Length만 바뀐 상태이다.

이제 더 들어가서, Capacity가 어떻게 늘어나고 줄어드는지 확인해보자. 몇 가지 실험을 해 보니, 어떻게 슬라이싱하는지에 따라 Capacity의 변화 모습이 다른 듯 하다.\

위에서 봤던 것처럼 슬라이스의 중간을 떼내면, 시작 포인터가 이동하고 Length가 변화한다. 하지만 배열은 그대로이므로 Capacity는 시작 포인터부터 배열 끝까지의 길이가 된다.
```go
slc := []int{1, 2, 3, 4, 5, 6, 7, 8}    // len : 8, cap : 8
slc = slc[2:5]                          // len : 3, cap : 6
```

슬라이싱할때 끝 인덱스를 주지 않아 시작점부터 끝까지 잘라도 동일한 현상이다.

```go
slc := []int{1, 2, 3, 4, 5, 6, 7, 8}    // len : 8, cap : 8
slc = slc[3:]                           // len : 5, cap : 5
```

만약 Length == Capacity인 상황에서, 즉 슬라이스가 꽉 찬 상황에서 새로운 요소를 append하면 Capacity가 어떻게 변화할까?

```go
slc := []int{1, 2, 3, 4, 5, 6, 7, 8}    // len : 8, cap : 8
slc = slc[3:]                           // len : 5, cap : 5
slc = append(slc, 9, 10)                // len : 7, cap : 10
```

Length == Capacity == 5인 상황에서 뒤에 두 개의 요소를 append했더니, Capacity가 두 배로 증가함을 볼 수 있었다.\
슬라이스는 내부 배열이 꽉 찰 경우, 스스로 __현재 Capacity의 두 배를 더 할당__ 받는다. Capacity가 6이었다면 append 후 12가 되었을 것이다.

### 슬라이스 복사

위에서 보았던 것처럼, 슬라이싱을 통해 새로 만들어진 슬라이스는 같은 배열을 공유한다.\
따라서 아래 코드에서 `new`를 수정하게 되면 `slc`까지 동시에 수정이 이루어진다. 참조하는 배열은 하나이기 때문이다.

```go
slc := []int{1, 2, 3, 4, 5, 6, 7, 8}    // slc : [1, 2, 3, 4, 5, 6, 7, 8]
new := slc[2:6]                         // new : [3, 4, 5, 6]
new[0] = 11
new[1] = 12
// new : [11, 12, 5, 6]
// slc : [1, 2, 11, 12, 5, 6, 7, 8]
```

실제로 개발할 때 많이 실수할 듯한 부분이다. 이런 예상치 못한 변경을 방지하기 위해서는 슬라이스를 직접 복사해서 사용해야 한다.\
슬라이스의 복사는 `copy` 함수를 이용한다.

```go
slc := []int{1, 2, 3, 4, 5, 6, 7, 8}
bbb := make([]int, len(slc[2:5]))
copy(bbb, slc[2:5])
```

먼저 복사할 만큼의 Length와 Capacity를 가지는 int 슬라이스를 만들어 놓고, `copy(dest, src)` 함수를 사용하여 복사한다.